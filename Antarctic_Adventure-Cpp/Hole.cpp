#include"Hole.h"
#include<cmath>
#include<stdlib.h>
#include<ctime>

const int Hole::form[5][9][11] =
{
	{//첫번째 형태는 항상 행의 인덱스가 3인 지점부터 시작하기. 그래야 배경에서 올바른 위치에 나타남.
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,1,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 }
	},
	{
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,5,5,5,0,0,0,0 },
		{ 0,0,0,0,7,7,7,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 }
	},
	{
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,5,5,5,0,0,0,0 },
		{ 0,0,0,5,7,7,7,5,0,0,0 },
		{ 0,0,0,0,7,7,7,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 }
		
	},
	{
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,5,5,5,5,5,0,0,0 },
		{ 0,0,5,7,7,7,7,7,5,0,0 },
		{ 0,0,7,7,7,7,7,7,7,0,0 },
		{ 0,0,0,7,7,7,7,7,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 }
	},
	{
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,5,5,5,5,5,5,5,0,0 },
		{ 0,5,7,7,7,7,7,7,7,5,0 },
		{ 0,7,7,7,7,7,7,7,7,7,0 },
		{ 0,0,7,7,7,7,7,7,7,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 },
		{ 0,0,0,0,0,0,0,0,0,0,0 }
	}
};

Hole::Hole(const int start_x) :Entity(start_x, 0)//10,12,14
{
	shape = 0;
	srand(time(NULL));
	x = 2 * (rand() % 4 + 5);
}

void Hole::movePos(Output* graphic){
	static int cnt = 0;
	static int num_cnt = 0;

	switch (cnt) {	//기본 모양 한칸씩 내리는거 없애기...그것때문에 제어못하는 경우가 좀 생기는거 같아..
	case 0: 
		shape = 0;
		y = 0;
		break;
	case 1:
		y = 1;
		break;
	case 2:
		shape = 1;//좌표 4는 하지말기
		y = 2;
		break;
	case 3:
		shape = 2;
		y = 3;
		break;
	case 4:
		shape = 2;
		y = 4;
		break;
	case 5:
		shape = 3;
		y = 6;
		break;
	case 6:
		shape = 3;
		y = 8;
		break;
	case 7:
		shape = 4;
		y = 10;
		break;
	case 8:	
		shape = 4;
		y = 13;
		break;
	case 9:
		shape = 4;
		y = 16;
		break;
	case 10:
		shape = 4;
		y = 18;
		cnt = 0;
		break;
	}
	if (num_cnt % 2)
		cnt++;
	num_cnt++;

	setPosX();	//x좌표 위치 결정.

	//memcpy(presentForm, form[shape%5], sizeof(int) * 9 * 11);//결정된 동작을 현재 형태에 복사
	presentForm = form[shape % 5];

	graphic->fixOnBoard(this);	//출력 보드에 현재 객체 배치. 좌표와 형태 모두 필요.
}

void Hole::setPosX() {
	float perspect_x ;//,perspect_y;
	static float init_x = x - 13.5;	//|11|12|13|14|15|16|
	static float slope = 8 / init_x;

	if (init_x == 0) {
		init_x = 14;
	}
	else {
		//perspect_y = (float)y;
		perspect_x = (float)(y+3) / slope;//3만큼 평행이동된 함수로 생각해줘야 함.
		x = (int)floor(perspect_x) + 14;	//반올림한뒤 시작점부터의 좌표를 더해줌
	}
}